// backend/controllers/inventoryController.js - FIXED VERSION
import InventoryBatch from "../models/InventoryBatch.js";
import Product from "../models/Product.js";
import { catchAsync, AppError } from "../middleware/errorHandler.js";
import mongoose from "mongoose";

// Add a new inventory batch - FIXED VERSION
export const addInventoryBatch = catchAsync(async (req, res, next) => {
  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    const {
      productId,
      purchaseDate,
      expiryDate,
      buyPrice,
      sellPrice,
      quantity,
      supplierName,
      invoiceNumber,
      shippingCost = 0,
      taxAmount = 0,
      otherCosts = 0,
      notes,
    } = req.body;

    console.log("ðŸ“¦ Adding inventory batch for product:", productId);

    // Enhanced validation
    if (!productId || productId.trim() === "") {
      await session.abortTransaction();
      throw new AppError("Product ID is required", 400);
    }

    // Validate that productId is a valid MongoDB ObjectId
    if (!mongoose.Types.ObjectId.isValid(productId)) {
      await session.abortTransaction();
      throw new AppError("Invalid Product ID format", 400);
    }

    // Check if product exists
    const product = await Product.findById(productId).session(session);
    if (!product) {
      await session.abortTransaction();
      throw new AppError("Product not found", 404);
    }

    if (!product.isActive) {
      await session.abortTransaction();
      throw new AppError("Cannot add batch to inactive product", 400);
    }

    // Validate required fields
    if (!buyPrice || Number(buyPrice) <= 0) {
      await session.abortTransaction();
      throw new AppError("Buy price must be greater than 0", 400);
    }

    if (!sellPrice || Number(sellPrice) <= 0) {
      await session.abortTransaction();
      throw new AppError("Sell price must be greater than 0", 400);
    }

    if (!quantity || Number(quantity) <= 0) {
      await session.abortTransaction();
      throw new AppError("Quantity must be greater than 0", 400);
    }

    // Create inventory batch with validated data
    const batch = new InventoryBatch({
      productId: mongoose.Types.ObjectId(productId), // Ensure it's an ObjectId
      // batchNumber will be auto-generated by the pre-save hook
      purchaseDate: purchaseDate ? new Date(purchaseDate) : new Date(),
      expiryDate: expiryDate ? new Date(expiryDate) : undefined,
      buyPrice: Number(buyPrice),
      sellPrice: Number(sellPrice),
      initialQuantity: Number(quantity),
      remainingQuantity: Number(quantity),
      supplierName: supplierName?.trim() || "Unknown Supplier",
      invoiceNumber: invoiceNumber?.trim() || `INV-${Date.now()}`,
      notes: notes?.trim() || "",
      costDetails: {
        shippingCost: Number(shippingCost) || 0,
        taxAmount: Number(taxAmount) || 0,
        otherCosts: Number(otherCosts) || 0,
      },
      status: "active",
    });

    await batch.save({ session });

    console.log(
      "âœ… Batch created with ID:",
      batch._id,
      "Batch Number:",
      batch.batchNumber
    );

    // Update product with new calculated values
    const aggregation = await InventoryBatch.aggregate([
      {
        $match: {
          productId: mongoose.Types.ObjectId(productId),
          status: "active",
          remainingQuantity: { $gt: 0 },
        },
      },
      {
        $group: {
          _id: null,
          totalQuantity: { $sum: "$remainingQuantity" },
          weightedBuyPrice: {
            $sum: {
              $multiply: ["$buyPrice", "$remainingQuantity"],
            },
          },
          weightedSellPrice: {
            $sum: {
              $multiply: ["$sellPrice", "$remainingQuantity"],
            },
          },
        },
      },
    ]).session(session);

    if (aggregation.length > 0) {
      const stats = aggregation[0];
      product.quantity = stats.totalQuantity;
      product.totalQuantity = stats.totalQuantity;
      product.currentBuyPrice =
        stats.totalQuantity > 0
          ? (stats.weightedBuyPrice / stats.totalQuantity).toFixed(2)
          : 0;
      product.currentSellPrice =
        stats.totalQuantity > 0
          ? (stats.weightedSellPrice / stats.totalQuantity).toFixed(2)
          : 0;

      await product.save({ session });
    }

    await session.commitTransaction();

    // Populate the product reference for the response
    await batch.populate("productId", "name category");

    res.status(201).json({
      status: "success",
      data: {
        batch,
        product: await Product.findById(productId),
      },
    });
  } catch (error) {
    await session.abortTransaction();
    console.error("âŒ Error in addInventoryBatch:", error);
    throw error;
  } finally {
    session.endSession();
  }
});

// Get all batches for a product
export const getProductBatches = catchAsync(async (req, res, next) => {
  const { productId } = req.params;
  const { status = "all" } = req.query;

  if (!mongoose.Types.ObjectId.isValid(productId)) {
    return next(new AppError("Invalid product ID format", 400));
  }

  const query = { productId: mongoose.Types.ObjectId(productId) };
  if (status !== "all") {
    query.status = status;
  }

  const batches = await InventoryBatch.find(query)
    .sort({ purchaseDate: 1 })
    .populate("productId", "name category");

  const summary = {
    totalBatches: batches.length,
    activeBatches: batches.filter((b) => b.status === "active").length,
    totalQuantity: batches.reduce((sum, b) => sum + b.remainingQuantity, 0),
    totalValue: batches.reduce(
      (sum, b) => sum + b.remainingQuantity * b.buyPrice,
      0
    ),
    oldestBatch: batches[0]?.purchaseDate,
    newestBatch: batches[batches.length - 1]?.purchaseDate,
  };

  res.status(200).json({
    status: "success",
    results: batches.length,
    data: {
      batches,
      summary,
    },
  });
});

// Get inventory valuation report
export const getInventoryValuation = catchAsync(async (req, res, next) => {
  const valuation = await InventoryBatch.aggregate([
    {
      $match: {
        status: "active",
        remainingQuantity: { $gt: 0 },
      },
    },
    {
      $lookup: {
        from: "products",
        localField: "productId",
        foreignField: "_id",
        as: "product",
      },
    },
    {
      $unwind: "$product",
    },
    {
      $group: {
        _id: "$product.category",
        totalQuantity: { $sum: "$remainingQuantity" },
        totalCostValue: {
          $sum: { $multiply: ["$remainingQuantity", "$buyPrice"] },
        },
        totalSellValue: {
          $sum: { $multiply: ["$remainingQuantity", "$sellPrice"] },
        },
        potentialProfit: {
          $sum: {
            $multiply: [
              "$remainingQuantity",
              { $subtract: ["$sellPrice", "$buyPrice"] },
            ],
          },
        },
        products: {
          $addToSet: {
            id: "$product._id",
            name: "$product.name",
            quantity: "$remainingQuantity",
            costValue: { $multiply: ["$remainingQuantity", "$buyPrice"] },
            sellValue: { $multiply: ["$remainingQuantity", "$sellPrice"] },
          },
        },
      },
    },
    {
      $sort: { totalCostValue: -1 },
    },
  ]);

  const totals = valuation.reduce(
    (acc, cat) => ({
      totalQuantity: acc.totalQuantity + cat.totalQuantity,
      totalCostValue: acc.totalCostValue + cat.totalCostValue,
      totalSellValue: acc.totalSellValue + cat.totalSellValue,
      potentialProfit: acc.potentialProfit + cat.potentialProfit,
    }),
    {
      totalQuantity: 0,
      totalCostValue: 0,
      totalSellValue: 0,
      potentialProfit: 0,
    }
  );

  res.status(200).json({
    status: "success",
    data: {
      byCategory: valuation,
      totals,
      profitMargin:
        totals.totalSellValue > 0
          ? ((totals.potentialProfit / totals.totalSellValue) * 100).toFixed(2)
          : 0,
    },
  });
});

// Get expiring batches
export const getExpiringBatches = catchAsync(async (req, res, next) => {
  const { days = 30 } = req.query;

  const expiryDate = new Date();
  expiryDate.setDate(expiryDate.getDate() + parseInt(days));

  const batches = await InventoryBatch.find({
    status: "active",
    remainingQuantity: { $gt: 0 },
    expiryDate: { $lte: expiryDate },
  })
    .populate("productId", "name category")
    .sort({ expiryDate: 1 });

  res.status(200).json({
    status: "success",
    results: batches.length,
    data: {
      batches,
      totalValue: batches.reduce(
        (sum, b) => sum + b.remainingQuantity * b.buyPrice,
        0
      ),
    },
  });
});

// Transfer inventory between batches
export const transferInventory = catchAsync(async (req, res, next) => {
  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    const { fromBatchId, toBatchId, quantity } = req.body;

    if (
      !mongoose.Types.ObjectId.isValid(fromBatchId) ||
      !mongoose.Types.ObjectId.isValid(toBatchId)
    ) {
      await session.abortTransaction();
      throw new AppError("Invalid batch ID format", 400);
    }

    const fromBatch = await InventoryBatch.findById(fromBatchId).session(
      session
    );
    const toBatch = await InventoryBatch.findById(toBatchId).session(session);

    if (!fromBatch || !toBatch) {
      await session.abortTransaction();
      throw new AppError("Batch not found", 404);
    }

    if (fromBatch.productId.toString() !== toBatch.productId.toString()) {
      await session.abortTransaction();
      throw new AppError("Cannot transfer between different products", 400);
    }

    if (fromBatch.remainingQuantity < quantity) {
      await session.abortTransaction();
      throw new AppError("Insufficient quantity in source batch", 400);
    }

    fromBatch.remainingQuantity -= quantity;
    toBatch.remainingQuantity += quantity;

    if (fromBatch.remainingQuantity === 0) {
      fromBatch.status = "depleted";
    }

    await fromBatch.save({ session });
    await toBatch.save({ session });

    await session.commitTransaction();

    res.status(200).json({
      status: "success",
      data: {
        fromBatch,
        toBatch,
      },
    });
  } catch (error) {
    await session.abortTransaction();
    throw error;
  } finally {
    session.endSession();
  }
});

// Get batch history for audit
export const getBatchHistory = catchAsync(async (req, res, next) => {
  const { batchId } = req.params;

  if (!mongoose.Types.ObjectId.isValid(batchId)) {
    return next(new AppError("Invalid batch ID format", 400));
  }

  const batch = await InventoryBatch.findById(batchId).populate(
    "productId",
    "name category"
  );

  if (!batch) {
    return next(new AppError("Batch not found", 404));
  }

  // Get all sales that used this batch
  const Sale = mongoose.model("Sale");
  const sales = await Sale.find({
    "products.batchAllocations.batchId": batchId,
  })
    .select("receiptNumber createdAt products cashierName totalAmount")
    .sort({ createdAt: -1 });

  // Calculate consumption
  const consumption = sales.reduce((acc, sale) => {
    sale.products.forEach((product) => {
      if (product.batchAllocations) {
        product.batchAllocations.forEach((allocation) => {
          if (allocation.batchId.toString() === batchId) {
            acc.push({
              date: sale.createdAt,
              receiptNumber: sale.receiptNumber,
              quantity: allocation.quantity,
              sellPrice: allocation.sellPrice,
              profit: allocation.profit,
            });
          }
        });
      }
    });
    return acc;
  }, []);

  res.status(200).json({
    status: "success",
    data: {
      batch,
      consumption,
      totalConsumed: batch.initialQuantity - batch.remainingQuantity,
      totalSales: consumption.length,
    },
  });
});

export default {
  addInventoryBatch,
  getProductBatches,
  getInventoryValuation,
  getExpiringBatches,
  transferInventory,
  getBatchHistory,
};
