import InventoryBatch from "../models/InventoryBatch.js";
import Product from "../models/Product.js";
import { catchAsync, AppError } from "../middleware/errorHandler.js";
import mongoose from "mongoose";
// Add a new inventory batch
export const addInventoryBatch = catchAsync(async (req, res, next) => {
  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    const {
      productId,
      purchaseDate,
      expiryDate,
      buyPrice,
      sellPrice,
      quantity,
      supplierName,
      invoiceNumber,
      shippingCost = 0,
      taxAmount = 0,
      otherCosts = 0,
      notes,
    } = req.body;

    // Enhanced validation
    if (!productId) {
      throw new AppError("Product ID is required", 400);
    }

    if (!supplierName || supplierName.trim() === "") {
      throw new AppError("Supplier name is required", 400);
    }

    if (!buyPrice || Number(buyPrice) <= 0) {
      throw new AppError("Buy price must be greater than 0", 400);
    }

    if (!sellPrice || Number(sellPrice) <= 0) {
      throw new AppError("Sell price must be greater than 0", 400);
    }

    if (!quantity || Number(quantity) <= 0) {
      throw new AppError("Quantity must be greater than 0", 400);
    }

    // Validate product exists
    const product = await Product.findById(productId);
    if (!product) {
      throw new AppError("Product not found", 404);
    }

    // Create inventory batch with validated data
    const batch = new InventoryBatch({
      productId,
      // batchNumber will be auto-generated by the pre-save hook
      purchaseDate: purchaseDate ? new Date(purchaseDate) : Date.now(),
      expiryDate: expiryDate ? new Date(expiryDate) : undefined,
      buyPrice: Number(buyPrice),
      sellPrice: Number(sellPrice),
      initialQuantity: Number(quantity),
      remainingQuantity: Number(quantity),
      supplierName: supplierName.trim(),
      invoiceNumber: invoiceNumber?.trim(),
      notes: notes?.trim(),
      costDetails: {
        shippingCost: Number(shippingCost) || 0,
        taxAmount: Number(taxAmount) || 0,
        otherCosts: Number(otherCosts) || 0,
      },
    });

    await batch.save({ session });

    // Update product with new calculated values
    await product.updateFromBatches();

    await session.commitTransaction();

    res.status(201).json({
      status: "success",
      data: {
        batch,
        product: await Product.findById(productId),
      },
    });
  } catch (error) {
    await session.abortTransaction();
    console.error("Error in addInventoryBatch:", error);
    throw error;
  } finally {
    session.endSession();
  }
});

// Get all batches for a product
export const getProductBatches = catchAsync(async (req, res, next) => {
  const { productId } = req.params;
  const { status = "all" } = req.query;

  const query = { productId };
  if (status !== "all") {
    query.status = status;
  }

  const batches = await InventoryBatch.find(query)
    .sort({ purchaseDate: 1 })
    .populate("productId", "name category");

  const summary = {
    totalBatches: batches.length,
    activeBatches: batches.filter((b) => b.status === "active").length,
    totalQuantity: batches.reduce((sum, b) => sum + b.remainingQuantity, 0),
    totalValue: batches.reduce(
      (sum, b) => sum + b.remainingQuantity * b.buyPrice,
      0
    ),
    oldestBatch: batches[0]?.purchaseDate,
    newestBatch: batches[batches.length - 1]?.purchaseDate,
  };

  res.status(200).json({
    status: "success",
    results: batches.length,
    data: {
      batches,
      summary,
    },
  });
});

// Get inventory valuation report
export const getInventoryValuation = catchAsync(async (req, res, next) => {
  const valuation = await InventoryBatch.aggregate([
    {
      $match: {
        status: "active",
        remainingQuantity: { $gt: 0 },
      },
    },
    {
      $lookup: {
        from: "products",
        localField: "productId",
        foreignField: "_id",
        as: "product",
      },
    },
    {
      $unwind: "$product",
    },
    {
      $group: {
        _id: "$product.category",
        totalQuantity: { $sum: "$remainingQuantity" },
        totalCostValue: {
          $sum: { $multiply: ["$remainingQuantity", "$buyPrice"] },
        },
        totalSellValue: {
          $sum: { $multiply: ["$remainingQuantity", "$sellPrice"] },
        },
        potentialProfit: {
          $sum: {
            $multiply: [
              "$remainingQuantity",
              { $subtract: ["$sellPrice", "$buyPrice"] },
            ],
          },
        },
        products: {
          $addToSet: {
            id: "$product._id",
            name: "$product.name",
            quantity: "$remainingQuantity",
            costValue: { $multiply: ["$remainingQuantity", "$buyPrice"] },
            sellValue: { $multiply: ["$remainingQuantity", "$sellPrice"] },
          },
        },
      },
    },
    {
      $sort: { totalCostValue: -1 },
    },
  ]);

  const totals = valuation.reduce(
    (acc, cat) => ({
      totalQuantity: acc.totalQuantity + cat.totalQuantity,
      totalCostValue: acc.totalCostValue + cat.totalCostValue,
      totalSellValue: acc.totalSellValue + cat.totalSellValue,
      potentialProfit: acc.potentialProfit + cat.potentialProfit,
    }),
    {
      totalQuantity: 0,
      totalCostValue: 0,
      totalSellValue: 0,
      potentialProfit: 0,
    }
  );

  res.status(200).json({
    status: "success",
    data: {
      byCategory: valuation,
      totals,
      profitMargin: (
        (totals.potentialProfit / totals.totalSellValue) *
        100
      ).toFixed(2),
    },
  });
});

// Get expiring batches
export const getExpiringBatches = catchAsync(async (req, res, next) => {
  const { days = 30 } = req.query;

  const expiryDate = new Date();
  expiryDate.setDate(expiryDate.getDate() + parseInt(days));

  const batches = await InventoryBatch.find({
    status: "active",
    remainingQuantity: { $gt: 0 },
    expiryDate: { $lte: expiryDate },
  })
    .populate("productId", "name category")
    .sort({ expiryDate: 1 });

  res.status(200).json({
    status: "success",
    results: batches.length,
    data: {
      batches,
      totalValue: batches.reduce(
        (sum, b) => sum + b.remainingQuantity * b.buyPrice,
        0
      ),
    },
  });
});

// Transfer inventory between batches
export const transferInventory = catchAsync(async (req, res, next) => {
  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    const { fromBatchId, toBatchId, quantity } = req.body;

    const fromBatch = await InventoryBatch.findById(fromBatchId).session(
      session
    );
    const toBatch = await InventoryBatch.findById(toBatchId).session(session);

    if (!fromBatch || !toBatch) {
      throw new AppError("Batch not found", 404);
    }

    if (fromBatch.productId.toString() !== toBatch.productId.toString()) {
      throw new AppError("Cannot transfer between different products", 400);
    }

    if (fromBatch.remainingQuantity < quantity) {
      throw new AppError("Insufficient quantity in source batch", 400);
    }

    fromBatch.remainingQuantity -= quantity;
    toBatch.remainingQuantity += quantity;

    if (fromBatch.remainingQuantity === 0) {
      fromBatch.status = "depleted";
    }

    await fromBatch.save({ session });
    await toBatch.save({ session });

    await session.commitTransaction();

    res.status(200).json({
      status: "success",
      data: {
        fromBatch,
        toBatch,
      },
    });
  } catch (error) {
    await session.abortTransaction();
    throw error;
  } finally {
    session.endSession();
  }
});

// Get batch history for audit
export const getBatchHistory = catchAsync(async (req, res, next) => {
  const { batchId } = req.params;

  const batch = await InventoryBatch.findById(batchId).populate(
    "productId",
    "name category"
  );

  if (!batch) {
    throw new AppError("Batch not found", 404);
  }

  // Get all sales that used this batch
  const Sale = mongoose.model("Sale");
  const sales = await Sale.find({
    "products.batchAllocations.batchId": batchId,
  })
    .select("receiptNumber createdAt products cashierName totalAmount")
    .sort({ createdAt: -1 });

  // Calculate consumption
  const consumption = sales.reduce((acc, sale) => {
    sale.products.forEach((product) => {
      product.batchAllocations.forEach((allocation) => {
        if (allocation.batchId.toString() === batchId) {
          acc.push({
            date: sale.createdAt,
            receiptNumber: sale.receiptNumber,
            quantity: allocation.quantity,
            sellPrice: allocation.sellPrice,
            profit: allocation.profit,
          });
        }
      });
    });
    return acc;
  }, []);

  res.status(200).json({
    status: "success",
    data: {
      batch,
      consumption,
      totalConsumed: batch.initialQuantity - batch.remainingQuantity,
      totalSales: consumption.length,
    },
  });
});

export default {
  addInventoryBatch,
  getProductBatches,
  getInventoryValuation,
  getExpiringBatches,
  transferInventory,
  getBatchHistory,
};
